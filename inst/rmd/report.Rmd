---
title: '**forester report**'
subtitle: 'version `r packageVersion("forester")`'
output:
  html_document:
    df_print: paged
    toc: true
    toc_depth: 2
date: '`r Sys.time()`'
version: 'forester `r packageVersion("forester")`'
params:
  models: NULL
  data: NULL
  y: NULL
  test_data: NULL
  train_data: NULL
  observed: NULL
  train_observed: NULL
  score: NULL
  best_models: NULL
  predictions: NULL
  metric_name: NULL
  type: 'regression'
  check_data: FALSE
  engine : NULL
  predictions_all : NULL
  raw_train : NULL
  predictions_best : NULL
  n_models: 10
  metric: NULL
  
---

```{r setup, include = FALSE}
library(DALEX)
library(forester)
knitr::opts_chunk$set(echo = FALSE, comment = NA, warning = FALSE, message = FALSE)
```

This report contains details about the best trained model, table with metrics for every trained model, scatter plot for chosen metric and info about used data.

# The best models
This is the **`r if(params$type == 'binary_clf'){'binary classification'}else{'regression'}`** task.  

 The best model is: 
**`r paste(names(params$train_output$best_models_on_valid[[1]][1]), sep="' '", collapse=", ")`**.

The names of the models were created by a pattern *Engine_TuningMethod_Id*, where:

- Engine describes the engine used for the training (random_forest, xgboost, decision_tree, lightgbm, catboost),

- TuningMethod describes how the model was tuned (basic for basic parameters, RS for random search, bayes for Bayesian optimization),

- Id for separating the random search parameters sets.

*More details about the best model are present at the end of the report.*


```{r table}
score_frame          <- params$train_output$score_valid
score_rounded        <- score_frame
for(i in 5:ncol(score_rounded)) {
  score_rounded[, i] <- round(as.numeric(score_rounded[, i]), 4)
}
if(!is.null(metric)){
  # & metric %in% c('rmse', 'mse', 'r2', 'mae', 'accuracy', 'auc', 'f1')
  score_rounded <- score_rounded[order(score_rounded[metric]), ]
  
} 
score_rounded <- score_rounded[1:n_models, -c(3, 4)]
knitr::kable(score_rounded)
```

```{r echo = FALSE}
train_predictions <- params$train_output$predictions_train
test_predictions  <- params$train_output$predictions_test
```

# Model comparison

```{r radar_plot, out.width = '90%'}
tryCatch({
      find.package('ggradar')
      score_radar <- params$train_output$score_valid[1:5, ]
      draw_radar_plot(score_radar, params$train_output$type)
    },
    error = function(cond) {
      verbose_cat('Package not found: ggradar, to use it please follow guides for',
                  'installation \nfrom GitHub repository README. Without the package',
                  'the radar plot will not be generated. \n\n', verbose = TRUE)
      return(NULL)
    })
```



```{r boxplot, out.width = '90%'}
if (params$train_output$type != 'binary_clf') {
  draw_boxplot(params$train_output$valid_observed, params$train_output$predictions_best_valid, params$train_output$best_models_on_valid)
}
```

```{r VS_plot, out.width = '100%'}
if (params$train_output$type != 'binary_clf') {
  draw_rmse_plot(train_predictions   = params$train_output$predictions_train,
                 train_observed      = params$train_output$train_observed,
                 test_predictions    = params$train_output$predictions_valid,
                 test_observed       = params$train_output$valid_observed,
                 models              = params$train_output$models_list)
}
```

## Plots for the best model - **`r names(train_output$best_models_on_valid[[1]][1])`**

```{r plots_for_the_best_model, out.width="50%"}
if (params$train_output$type == 'binary_clf') {
  tryCatch(
    expr = {
       print(draw_roc_plot(params$train_output$best_models_on_valid[[1]][1], params$train_output$valid_data, params$train_output$valid_observed))
    },
    error = function(e) {
      
    }
  )
  
  draw_confusion_matrix(params$train_output$best_models_on_valid[[1]][1], params$train_output$valid_data, params$train_output$valid_observed)
} else {
  best_name <- names(params$train_output$best_models_on_valid[[1]][1])
  best_idx  <- NULL
  
  for (i in 1:length(names(params$train_output$best_models_on_valid[i]))) {
    if (best_name == names(params$train_output$best_models_on_valid[i])) {
      best_idx <- i
    }
  }
  
  plt <- draw_scatterplot(train_observed    = params$train_output$train_observed,
                          train_predictions = train_predictions[[best_idx]],
                          test_observed     = params$train_output$valid_observed,
                          test_predictions  = test_predictions[[best_idx]])
  
  plot(plt$plt1)
  plot(plt$plt2)
}
```


## Feature Importance for the best model -  **`r names(params$train_output$best_models_on_valid[[1]][1])`**

```{r feature_importance}
engine <- NULL
if (grepl('ranger', names(params$train_output$best_models_on_valid[[1]][1]))) {
  engine <- c('ranger')
} else if (grepl('xgboost', names(params$train_output$best_models_on_valid[[1]][1]))) {
  engine <- c('xgboost')
} else if (grepl('decision_tree', names(params$train_output$best_models_on_valid[[1]][1]))) {
  engine <- c('decision_tree')
} else if (grepl('lightgbm', names(params$train_output$best_models_on_valid[[1]][1]))) {
  engine <- c('lightgbm')
} else if (grepl('catboost', names(params$train_output$best_models_on_valid[[1]][1]))) {
  engine <- c('catboost')
}

if (engine != c('catboost') && !is.null(engine)) { # For catboost there is an error with DALEX::model_parts().
  draw_feature_importance(params$train_output$best_models_on_valid, params$train_output$valid_data, params$train_output$y)
} else {
  print('Feature importance unavailable for catboost model.')
}
```

## Details about data
```{r check_data, results = 'asis'}
checked_data <- check_data(params$train_output$data, params$train_output$y, verbose = FALSE)
for (i in 1:length(checked_data$str)) {
  cat(checked_data$str[i])
  cat('\n')
}
```

## The best model details
```{r}
options(width = 100)
format_models_details(params$train_output$best_models_on_valid[[1]][1])
```
